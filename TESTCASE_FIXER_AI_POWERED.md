# 测试用例修复工具 - AI驱动版本

## 概述

将测试用例修复工具升级为完全由AI驱动，包括问题检测和修复两个阶段都使用AI处理。

## 核心改进

### 之前的设计

- **扫描问题**：使用硬编码规则检测（检查省略号、重复标记等）
- **修复问题**：使用AI修复

**问题：**
- 硬编码规则可能遗漏某些问题
- 硬编码规则可能误报
- 无法处理复杂的格式问题

### 现在的设计

- **扫描问题**：使用AI分析测试用例质量
- **修复问题**：使用AI修复

**优势：**
- AI可以理解题目语义
- AI可以发现更多类型的问题
- AI可以减少误报
- 更智能、更准确

## 工作流程

### 完整流程

```
打开工具
    ↓
显示所有题目列表
    ↓
用户选择要检查的题目
    ↓
点击"扫描问题"按钮
    ↓
AI逐个分析测试用例质量 ← AI驱动
    ↓
显示AI分析结果
    ↓
点击"修复选中"按钮
    ↓
AI逐个修复有问题的测试用例 ← AI驱动
    ↓
完成，自动刷新题库
```

### AI扫描阶段

**对每个选中的题目：**

1. 加载题目和测试用例
2. 生成扫描提示词
3. 调用AI分析
4. 解析AI响应
5. 更新列表项显示
6. 继续下一个题目

**AI扫描提示词：**

```
你是一个测试用例质量检查专家。请分析以下C++编程题目的测试用例，判断是否存在问题。

【题目信息】
标题：数组操作
描述：...

【测试用例】
测试用例 1：
描述：基本功能测试
输入：
5 1
1 2 3 4 5

期望输出：
15

...

【检查要点】
1. 输入数据是否包含省略号（...）或"重复"标记
2. 输入数据是否完整、可直接使用
3. 输入数据格式是否符合题目要求
4. 期望输出是否完整
5. 测试用例描述与实际数据是否匹配

【输出格式】
请以JSON格式输出分析结果：
{
    "hasIssues": true/false,
    "problematicIndices": [1, 3, 5],
    "summary": "简要说明发现的问题"
}
```

**AI响应示例：**

```json
{
    "hasIssues": true,
    "problematicIndices": [3, 5],
    "summary": "测试用例3和5的输入数据包含省略号，需要展开为完整数据"
}
```

### AI修复阶段

**对每个有问题的题目：**

1. 加载题目和问题测试用例
2. 生成修复提示词
3. 调用AI修复
4. 解析AI响应
5. 应用修复并保存
6. 继续下一个题目

**AI修复提示词：**（与之前相同）

```
你是一个测试用例修复专家。请修复以下C++编程题目的测试用例。

【题目信息】
标题：...
描述：...

【有问题的测试用例】
测试用例 3：
描述：大数据测试
当前输入：
100 1
1 0
...（重复100行）
0 0

期望输出：
100 0

【修复要求】
1. 将所有省略号（...）和"重复"标记展开为完整的输入数据
2. 确保输入格式符合题目要求
3. 输入数据要完整、准确、可直接使用
4. 保持原有的测试用例描述和期望输出不变

【输出格式】
请以JSON格式输出修复后的测试用例：
[
    {
        "index": 3,
        "description": "大数据测试",
        "input": "100 1\n1 0\n1 0\n...(完整展开)",
        "output": "100 0"
    }
]
```

## 技术实现

### 数据结构

```cpp
enum OperationMode {
    Idle,      // 空闲
    Scanning,  // 扫描中
    Fixing     // 修复中
};

OperationMode m_currentMode;
int m_currentScanIndex;  // 当前扫描索引
int m_currentFixIndex;   // 当前修复索引
```

### 核心方法

#### scanNextQuestion()
```cpp
// AI扫描下一个题目
void TestCaseFixerDialog::scanNextQuestion()
{
    // 1. 检查是否完成
    if (m_currentScanIndex >= m_selectedIndices.size()) {
        // 显示扫描结果
        return;
    }
    
    // 2. 加载题目
    // 3. 生成扫描提示词
    QString prompt = generateScanPrompt(m_currentQuestion);
    
    // 4. 调用AI
    m_aiClient->sendChatMessage(prompt, "");
}
```

#### generateScanPrompt()
```cpp
// 生成AI扫描提示词
QString TestCaseFixerDialog::generateScanPrompt(const Question &question)
{
    // 包含题目信息
    // 包含所有测试用例
    // 包含检查要点
    // 要求JSON格式输出
}
```

#### applyAIScanResult()
```cpp
// 应用AI扫描结果
void TestCaseFixerDialog::applyAIScanResult()
{
    // 1. 解析JSON响应
    // 2. 提取hasIssues和problematicIndices
    // 3. 更新QuestionItem
    // 4. 更新列表项显示
    // 5. 继续下一个
}
```

#### onAIFinished()
```cpp
// AI响应完成
void TestCaseFixerDialog::onAIFinished()
{
    if (m_currentMode == Scanning) {
        applyAIScanResult();  // 应用扫描结果
    } else if (m_currentMode == Fixing) {
        applyAIFix();  // 应用修复结果
    }
}
```

### 状态管理

```cpp
// 扫描状态
m_isScanning = true;
m_currentMode = Scanning;
m_currentScanIndex = 0;

// 修复状态
m_isFixing = true;
m_currentMode = Fixing;
m_currentFixIndex = 0;

// 空闲状态
m_currentMode = Idle;
```

## UI反馈

### 扫描阶段

**状态标签：**
```
🔍 正在扫描 1/10 - 数组操作题
```

**进度条：**
```
[=========>          ] 1/10 - 10%
```

**日志：**
```
🔍 开始AI扫描 10 个题目...

[1/10] 正在AI分析：数组操作题
✅ 正常

[2/10] 正在AI分析：字符串处理
⚠️ 发现问题：测试用例3和5的输入数据包含省略号

...
```

### 修复阶段

**状态标签：**
```
🚀 正在修复 1/3 - 字符串处理
```

**进度条：**
```
[=========>          ] 1/3 - 33%
```

**日志：**
```
========== 开始AI修复 ==========

[1/3] 正在AI修复：字符串处理
✅ 成功修复并保存 2 个测试用例

...
```

## AI分析优势

### 1. 语义理解

**硬编码规则：**
```cpp
if (tc.input.contains("...")) {
    hasIssue = true;  // 简单字符串匹配
}
```

**AI分析：**
- 理解题目要求
- 理解测试用例描述
- 判断数据是否符合题目语义
- 发现格式不匹配问题

### 2. 更全面的检查

**硬编码规则只能检查：**
- 省略号
- 重复标记
- 数据长度

**AI可以检查：**
- 数据完整性
- 格式正确性
- 语义一致性
- 描述匹配性
- 边界条件合理性

### 3. 减少误报

**硬编码规则：**
```cpp
// 检测所有中文括号，导致误报
if (tc.input.contains("（")) {
    hasIssue = true;
}
```

**AI分析：**
- 理解中文括号的上下文
- 判断是否是正常的题目描述
- 只标记真正有问题的情况

### 4. 自适应

**硬编码规则：**
- 固定的检查逻辑
- 无法适应新的问题类型

**AI分析：**
- 可以发现新类型的问题
- 可以适应不同的题目风格
- 可以学习和改进

## 性能考虑

### AI调用次数

**扫描阶段：**
- 每个选中的题目调用一次AI
- 例如：选择10个题目 = 10次AI调用

**修复阶段：**
- 每个有问题的题目调用一次AI
- 例如：3个题目有问题 = 3次AI调用

**总计：**
- 扫描10个题目，3个有问题 = 13次AI调用

### 优化建议

1. **批量扫描**：一次AI调用分析多个题目（需要修改提示词）
2. **缓存结果**：缓存扫描结果，避免重复扫描
3. **并行处理**：同时调用多个AI实例（如果支持）

## 测试要点

### AI扫描测试

- [ ] AI能正确识别有问题的测试用例
- [ ] AI能正确识别正常的测试用例
- [ ] AI响应格式正确
- [ ] JSON解析正常
- [ ] 列表项显示正确更新

### AI修复测试

- [ ] AI能正确修复问题
- [ ] 修复后的数据格式正确
- [ ] 修复后的数据完整
- [ ] 保存功能正常

### 错误处理

- [ ] AI调用失败时正确处理
- [ ] JSON格式错误时正确处理
- [ ] 停止按钮正常工作

### 用户体验

- [ ] 进度条正确显示
- [ ] 状态标签实时更新
- [ ] 日志信息清晰
- [ ] 完成后自动刷新

## 优势总结

| 方面 | 硬编码规则 | AI驱动 |
|------|-----------|--------|
| 准确性 | 中等 | 高 |
| 覆盖范围 | 有限 | 全面 |
| 误报率 | 较高 | 低 |
| 适应性 | 差 | 好 |
| 语义理解 | 无 | 有 |
| 维护成本 | 高 | 低 |
| 扩展性 | 差 | 好 |

## 示例对比

### 场景1：正常的中文括号

**输入：**
```
输入第一行包含两个整数n和m（1≤n≤100）
```

**硬编码规则：**
```
❌ 误报：包含中文括号
```

**AI分析：**
```
✅ 正常：这是题目描述的一部分
```

### 场景2：复杂的格式问题

**输入：**
```
测试用例描述：大数据测试（10000行）
实际输入：只有10行数据
```

**硬编码规则：**
```
✅ 未检测到：没有省略号或重复标记
```

**AI分析：**
```
⚠️ 发现问题：描述说10000行，但实际只有10行
```

### 场景3：语义不匹配

**输入：**
```
测试用例描述：边界条件测试
实际输入：普通的中间值
```

**硬编码规则：**
```
✅ 未检测到：数据格式正确
```

**AI分析：**
```
⚠️ 发现问题：描述说边界条件，但数据不是边界值
```

## 后续优化

1. **批量扫描**：一次AI调用分析多个题目
2. **智能缓存**：缓存扫描结果
3. **增量扫描**：只扫描修改过的题目
4. **AI模型优化**：使用专门训练的模型
5. **并行处理**：提高扫描速度
