# 会话恢复问题诊断与修复

## 问题描述
第二阶段的会话保存与恢复功能没有正常工作：
- 展开的文件夹没有恢复
- 选中的题目没有恢复
- 启动时没有自动恢复面板状态

## 根本原因

### 问题 1：数据保存不一致
SessionManager 有两套保存机制：

1. **简单保存** (`saveSession`)：
   - 只保存 questionBankPath, currentQuestionIndex, questionId
   - 直接写入 JSON 文件
   - 覆盖整个文件

2. **完整保存** (`saveSessionState`)：
   - 保存完整的 SessionState（包括面板状态）
   - 写入同一个 JSON 文件
   - 也会覆盖整个文件

**问题**：两个方法写入同一个文件，互相覆盖！

### 问题 2：数据加载不一致

1. **简单加载** (`loadSession`)：
   - 直接从 JSON 读取基本字段
   - 不读取面板状态

2. **面板状态加载** (`loadPanelState`)：
   - 调用 `loadSessionState()` 读取完整状态
   - 但如果文件是由 `saveSession()` 保存的，就没有面板状态数据

### 问题 3：保存时机冲突

在 `closeEvent` 中：
```cpp
// 1. 先调用 saveSession（覆盖文件，丢失面板状态）
SessionManager::instance().saveSession(m_currentBankPath, m_currentQuestionIndex);

// 2. 再调用 savePanelState（覆盖文件，丢失基本信息）
SessionManager::instance().savePanelState(expandedPaths, selectedPath);
```

结果：最后保存的数据可能不完整！

## 解决方案

### 统一使用 SessionState

所有保存和加载都通过 `SessionState` 进行：

#### 1. 修改 saveSession
```cpp
void SessionManager::saveSession(const QString &questionBankPath, int currentQuestionIndex, const QString &questionId)
{
    // 加载现有的 SessionState 并更新
    SessionState state = loadSessionState();
    state.questionBankPath = questionBankPath;
    state.currentQuestionIndex = currentQuestionIndex;
    state.currentQuestionId = questionId;
    state.lastSaved = QDateTime::currentDateTime();
    
    // 保存完整的 SessionState
    saveSessionState(state);
}
```

**改进**：
- 不再直接写入 JSON
- 先加载现有状态
- 只更新需要的字段
- 保存完整状态

#### 2. 修改 loadSession
```cpp
bool SessionManager::loadSession(QString &questionBankPath, int &currentQuestionIndex, QString &questionId)
{
    // 从完整的 SessionState 加载
    SessionState state = loadSessionState();
    questionBankPath = state.questionBankPath;
    currentQuestionIndex = state.currentQuestionIndex;
    questionId = state.currentQuestionId;
    
    return !questionBankPath.isEmpty();
}
```

**改进**：
- 不再直接读取 JSON
- 使用 `loadSessionState()` 统一加载
- 保证数据一致性

#### 3. savePanelState 保持不变
```cpp
void SessionManager::savePanelState(const QStringList &expandedPaths, const QString &selectedQuestionPath)
{
    // 加载现有的 SessionState 并更新面板状态
    SessionState state = loadSessionState();
    state.expandedBankPaths = expandedPaths;
    state.selectedQuestionPath = selectedQuestionPath;
    state.lastSaved = QDateTime::currentDateTime();
    
    // 保存完整的 SessionState
    saveSessionState(state);
}
```

**已经正确**：
- 加载现有状态
- 只更新面板字段
- 保存完整状态

#### 4. 修改 closeEvent 保存顺序
```cpp
void MainWindow::closeEvent(QCloseEvent *event)
{
    // 保存会话（使用当前题库路径和题目ID）
    if (m_questionBank->count() > 0 && !m_currentBankPath.isEmpty()) {
        QString questionId;
        if (m_currentQuestionIndex >= 0 && m_currentQuestionIndex < m_questionBank->count()) {
            questionId = m_questionBank->allQuestions()[m_currentQuestionIndex].id();
        }
        SessionManager::instance().saveSession(m_currentBankPath, m_currentQuestionIndex, questionId);
        qDebug() << "[MainWindow] Saved session - Bank:" << m_currentBankPath << "Index:" << m_currentQuestionIndex << "ID:" << questionId;
    }
    
    // 保存窗口状态
    SessionManager::instance().saveWindowState(saveGeometry(), saveState());
    
    // 保存题库面板状态（展开的文件夹和选中的题目）
    if (m_questionBankPanel) {
        QStringList expandedPaths = m_questionBankPanel->getExpandedPaths();
        QString selectedPath = m_questionBankPanel->getSelectedQuestionPath();
        SessionManager::instance().savePanelState(expandedPaths, selectedPath);
        qDebug() << "[MainWindow] Saved panel state - Expanded:" << expandedPaths.size() << "Selected:" << selectedPath;
    }
    
    event->accept();
}
```

**改进**：
- 添加题目ID保存
- 添加调试日志
- 现在两次保存都会合并到同一个 SessionState

## 数据流

### 保存流程
```
closeEvent()
    ↓
saveSession(path, index, id)
    ↓
loadSessionState()  // 加载现有状态
    ↓
更新 questionBankPath, currentQuestionIndex, currentQuestionId
    ↓
saveSessionState(state)  // 保存完整状态
    ↓
savePanelState(paths, selected)
    ↓
loadSessionState()  // 再次加载（包含刚才保存的基本信息）
    ↓
更新 expandedBankPaths, selectedQuestionPath
    ↓
saveSessionState(state)  // 再次保存（现在包含所有信息）
```

### 加载流程
```
loadLastSession()
    ↓
loadSession(path, index, id)
    ↓
loadSessionState()  // 加载完整状态
    ↓
提取 questionBankPath, currentQuestionIndex, currentQuestionId
    ↓
loadPanelState(paths, selected)
    ↓
loadSessionState()  // 再次加载（同一个状态）
    ↓
提取 expandedBankPaths, selectedQuestionPath
```

## 数据结构

### SessionState（完整状态）
```cpp
struct SessionState {
    // 题库信息
    QString questionBankPath;
    int currentQuestionIndex;
    QString currentQuestionId;
    
    // 题库面板状态
    QStringList expandedBankPaths;
    QString selectedQuestionPath;
    
    // 窗口状态
    QByteArray windowGeometry;
    QByteArray windowState;
    
    // ... 其他字段 ...
    
    QDateTime lastSaved;
};
```

### JSON 文件（data/last_session.json）
```json
{
    "questionBankPath": "data/基础题库/CCF",
    "currentQuestionIndex": 5,
    "currentQuestionId": "32_7899962939002065332",
    "expandedBankPaths": [
        "data/基础题库",
        "data/基础题库/CCF",
        "data/基础题库/CCF/算法"
    ],
    "selectedQuestionPath": "data/基础题库/CCF/算法/树上搜索.json",
    "windowGeometry": "...",
    "windowState": "...",
    "lastSaved": "2025-12-05T23:00:00"
}
```

## 测试验证

### 测试步骤
1. **保存测试**
   - 展开几个文件夹
   - 选择一道题目
   - 关闭程序
   - 检查 `data/last_session.json` 文件
   - 验证包含 `expandedBankPaths` 和 `selectedQuestionPath`

2. **恢复测试**
   - 重新打开程序
   - 验证文件夹展开状态
   - 验证题目选中状态
   - 检查调试日志

3. **多次保存测试**
   - 切换题目
   - 展开/折叠文件夹
   - 关闭程序
   - 重新打开
   - 验证最新状态被恢复

### 调试日志
```
[MainWindow] Saved session - Bank: data/基础题库/CCF Index: 5 ID: 32_7899962939002065332
[MainWindow] Saved panel state - Expanded: 3 Selected: data/基础题库/CCF/算法/树上搜索.json
[MainWindow] Restored panel state - Expanded: 3 Selected: data/基础题库/CCF/算法/树上搜索.json
[MainWindow] Found question by ID: 32_7899962939002065332 at index: 5
```

## 相关文件

### 修改的文件
- `src/utils/SessionManager.cpp` - 统一使用 SessionState
- `src/ui/MainWindow.cpp` - 添加题目ID保存和调试日志

### 数据文件
- `data/last_session.json` - 会话数据文件

## 总结

### 问题根源
- 两套保存机制互相覆盖
- 数据加载不一致
- 保存时机冲突

### 解决方案
- ✅ 统一使用 SessionState
- ✅ 所有保存都先加载再更新
- ✅ 所有加载都从 SessionState 读取
- ✅ 添加调试日志

### 预期效果
- ✅ 展开的文件夹正确恢复
- ✅ 选中的题目正确恢复
- ✅ 题目内容正确加载
- ✅ 数据不会丢失

现在会话恢复功能应该可以正常工作了！
