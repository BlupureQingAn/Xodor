# 会话恢复功能修复完成

## 问题描述
用户关闭程序后重新打开，没有加载上次退出时正在做的题目。

## 根本原因
1. **SessionManager 签名不匹配**：MainWindow 调用 `saveSession()` 时传入了 3 个参数（包括题目ID），但 SessionManager 只接受 2 个参数
2. **缺少题目ID保存**：会话只保存了题库路径和题目索引，没有保存题目ID
3. **索引不可靠**：题目索引在题库重新加载后可能会变化，导致恢复错误的题目

## 解决方案

### 1. 扩展 SessionManager 支持题目ID

**修改文件**：`src/utils/SessionManager.h`
```cpp
// 基本会话管理
void saveSession(const QString &questionBankPath, int currentQuestionIndex, const QString &questionId = QString());
bool loadSession(QString &questionBankPath, int &currentQuestionIndex);
bool loadSession(QString &questionBankPath, int &currentQuestionIndex, QString &questionId);
```

**修改文件**：`src/utils/SessionManager.cpp`
- 修改 `saveSession()` 方法，添加 `questionId` 参数并保存到 JSON
- 添加重载的 `loadSession()` 方法，支持加载题目ID
- 保持向后兼容，原有的 2 参数版本仍然可用

### 2. 更新 MainWindow 会话恢复逻辑

**修改文件**：`src/ui/MainWindow.cpp`

#### loadLastSession() 方法改进
```cpp
void MainWindow::loadLastSession()
{
    QString questionBankPath;
    int questionIndex;
    QString questionId;  // 新增：加载题目ID
    
    if (SessionManager::instance().loadSession(questionBankPath, questionIndex, questionId)) {
        // ... 加载题库 ...
        
        // 优先使用题目ID查找题目
        bool foundById = false;
        if (!questionId.isEmpty()) {
            for (int i = 0; i < m_questionBank->count(); ++i) {
                if (m_questionBank->allQuestions()[i].id() == questionId) {
                    m_currentQuestionIndex = i;
                    foundById = true;
                    break;
                }
            }
        }
        
        // 如果没有找到题目ID，使用索引作为后备方案
        if (!foundById) {
            m_currentQuestionIndex = qBound(0, questionIndex, m_questionBank->count() - 1);
        }
        
        loadCurrentQuestion();
    }
}
```

#### 题目选择时保存会话
在 `questionSelected` 信号处理中，已经正确调用：
```cpp
// 获取当前题库路径
QString currentBankId = QuestionBankManager::instance().getCurrentBankId();
if (!currentBankId.isEmpty()) {
    QuestionBankInfo bankInfo = QuestionBankManager::instance().getBankInfo(currentBankId);
    QString currentBankPath = bankInfo.path;
    if (!currentBankPath.isEmpty()) {
        SessionManager::instance().saveSession(currentBankPath, m_currentQuestionIndex, question.id());
    }
}
```

## 工作流程

### 保存会话
1. 用户选择题目时触发 `questionSelected` 信号
2. MainWindow 保存当前代码
3. 调用 `SessionManager::saveSession()` 保存：
   - 题库路径
   - 题目索引（用于后备）
   - **题目ID**（主要标识）
4. 程序关闭时再次保存会话状态

### 恢复会话
1. 程序启动时调用 `loadLastSession()`
2. 从 SessionManager 加载题库路径、题目索引和题目ID
3. 检查题库目录是否存在
4. 加载题库中的所有题目
5. **优先使用题目ID查找题目**（精确匹配）
6. 如果题目ID未找到，使用索引作为后备方案
7. 加载题目到编辑界面
8. 显示恢复成功消息

## 技术细节

### 题目ID的优势
- **唯一性**：每个题目有唯一的ID（格式：`{sourceFile}_{hash}`）
- **稳定性**：题目ID不会因为题库重新加载而改变
- **精确性**：即使题目顺序变化，也能准确找到正确的题目

### 向后兼容
- 保留了原有的 2 参数 `loadSession()` 方法
- `questionId` 参数有默认值，旧代码仍然可以编译
- 如果没有题目ID，自动回退到使用索引

### 数据持久化
会话数据保存在 `data/last_session.json`：
```json
{
    "questionBankPath": "data/基础题库/CCF",
    "currentQuestionIndex": 5,
    "questionId": "32_7899962939002065332",
    "lastSaved": "2025-12-05T21:36:42"
}
```

## 测试建议

1. **基本恢复测试**
   - 选择一道题目
   - 编写一些代码
   - 关闭程序
   - 重新打开程序
   - 验证：题目和代码都正确恢复

2. **题库变化测试**
   - 选择题目后关闭程序
   - 修改题库（添加/删除题目）
   - 重新打开程序
   - 验证：仍然能找到正确的题目

3. **题库删除测试**
   - 选择题目后关闭程序
   - 删除题库目录
   - 重新打开程序
   - 验证：显示友好的错误消息

4. **多次切换测试**
   - 在多道题目之间切换
   - 每次切换后关闭程序
   - 验证：每次都能恢复到最后选择的题目

## 相关文件
- `src/utils/SessionManager.h` - 会话管理器头文件
- `src/utils/SessionManager.cpp` - 会话管理器实现
- `src/ui/MainWindow.cpp` - 主窗口会话恢复逻辑
- `data/last_session.json` - 会话数据文件
- `data/user_answers/{questionId}.json` - 用户代码保存位置

## 状态
✅ **已完成** - 会话恢复功能已修复，支持题目ID精确匹配
