以下是整理好的第35次CCF计算机软件能力认证（CSP）模拟试题集合。

---

# 第35次CCF计算机软件能力认证

## 题目 1：密码 (Password)

**时间限制：** 1.0 秒
**空间限制：** 512 MiB

### 题目背景

西西艾弗网对用户密码有一套安全级别评定标准。

### 题目描述

在西西艾弗网上，用户的密码是一个由大写字母（A-Z）、小写字母（a-z）、数字（0-9）和特殊字符（* 和 #）共 64 种字符组成的字符串。

根据复杂程度不同，密码安全度被分为高、中、低三档。

* **高**：由上述 64 种字符组成，长度大于等于 6 个字符，包含字母、数字和特殊字符，同一个字符出现不超过 2 次；
* **中**：由上述 64 种字符组成，长度大于等于 6 个字符，包含字母、数字和特殊字符，且未达到高安全度要求；
* **低**：由上述 64 种字符组成，长度大于等于 6 个字符，且未达到中安全度要求；

小 P 为自己准备了 $n$ 个候选密码，试编写程序帮小 P 自动判别每个密码的安全级别。保证这 $n$ 个密码都至少满足低安全度要求，当安全度为高、中、低时分别输出 2、1、0 即可。

### 输入格式

从标准输入读入数据。
输入共 $n+1$ 行。
第一行包含一个正整数 $n$，表示待判别的密码个数；
接下来 $n$ 行，每行一个字符串，表示一个安全度至少为低的候选密码。

### 输出格式

输出到标准输出。
输出共 $n$ 行，每行输出一个整数 2、1 或 0，表示对应密码的安全度。

### 样例

**输入：**

```text
4
csp#ccsp
csp#ccsp2024
Csp#ccsp2024
CSP#2024
```

**输出：**

```text
0
1
2
2
```

**样例解释：**

* 第一个密码不含数字，安全度为低；
* 第二个密码中小写字母 c 出现 3 次，安全度为中；
* 和第二个密码相比，第三个密码把一个小写字母 c 变为了大写，满足了高安全度要求；
* 第四个密码同样满足高安全度要求。

### 子任务

全部的测试数据满足 $n \le 100$，且输入的每个字符串均不超过 20 个字符。

---

## 题目 2：字符串变换 (String Transformation)

**时间限制：** 1.0 秒
**空间限制：** 512 MiB

### 题目描述

本题涉及字符包括大小写字母（A-Z 和 a-z）、数字（0-9）和空格共 63 种。在这个字符集合上，小 P 定义了一个字符替换函数 $f(ch)$，表示将字符 $ch$ 替换为 $f(ch)$。 例如 $f(a)=b$ 表示将 a 替换为 b，$f(b)=0$ 表示将 b 替换为 0。 进而可以将其扩展为字符串变换函数 $F(s)$，表示对字符串 s 进行变换，将 s 中每个字符 $ch$ 都替换为 $f(ch)$。

字符替换函数 $f$ 可表示为 $n$ 个字符对 $(ch_1, ch_2)$，即 $f(ch_1)=ch_2$。

* $n$ 个字符对中，$ch_1$ 两两不同；
* 未定义的 $f(ch)$，可视为 $f(ch)=ch$，即字符 $ch$ 保持不变；
* 函数 $f$ 为单射，即当 $ch_1 \ne ch_2$ 时有 $f(ch_1) \ne f(ch_2)$。

现给定初始字符串 s，试处理 $m$ 个查询：每个查询包含一个正整数 $k$，询问对初始字符串 s 变换 $k$ 次后的结果 $F^k(s)$。

### 输入格式

从标准输入读入数据。
输入共 $n+4$ 行。
输入的第一行包含一个字符串，形如 `#s#`，即用两个井号字符 `#` 将初始字符串 s 囊括其中。
输入的第二行包含一个正整数 $n$，表示组成函数 $f$ 的字符对数；接下来 $n$ 行每行输入一个形如 `#xy#` 的字符串，表示 $f(x)=y$。
输入的第 $n+3$ 行包含一个正整数 $m$，表示查询的个数；下一行包含空格分隔的 $m$ 个正整数 $k_1, k_2, \dots, k_m$，表示 $m$ 个查询。

### 输出格式

输出到标准输出。
输出共 $m$ 行，依次输出 $m$ 个查询的结果；输出时每行同样是一个形如 `#s#` 的字符串，即用两个井号把变换后的字符串 s 括起。

### 样例

**输入：**

```text
#Hello World#
6
#HH#
#e #
# r#
#re#
#oa#
#ao#
3
1 2 3
```

**输出：**

```text
#H llarWaeld#
#HrlloeWo ld#
#Hella Warld#
```

### 子任务

* 前 60% 的测试数据保证初始字符串 s 仅包含小写字母，且输入的 $n$ 个字符对也皆为小写字母；
* 前 80% 的测试数据保证查询数量 $m \le 10$、变换次数 $k \le 100$；
* 全部测试数据保证 $0 < n \le 63$、$0 < m \le 10^3$、$0 < k \le 10^9$ 且初始字符串 s 包含不超过 100 个字符。

### 提示

由于读入的字符串中包含空格字符，推荐使用按行读取的方式（如 C 的 `fgets`，C++ 的 `getline`，Python 的 `input`）。

---

## 题目 3：补丁应用 (Patch Application)

**时间限制：** 1.0 秒
**空间限制：** 512 MiB

### 题目背景

西西艾弗岛运营公司的信息技术部门需要协作开展程序开发。开发者使用 diff 工具生成补丁，审查者确认后使用 patch 程序将修改应用到原代码上。你需要实现这个 patch 程序。

### 题目描述

patch 程序处理 diff 的输出（补丁）。补丁由一个或多个块组成。
每个块的第一行形如：`@@ -NN,MM +nn,mm @@`

* `NN, MM`：修改在原文件的第 NN 行开始，涉及 MM 行。
* `nn, mm`：修改后在新文件的第 nn 行开始，共 mm 行（处理时忽略 nn）。
* 随后的文本行：`-` 开头表示删除，`+` 开头表示添加，空格开头表示上下文（不变）。
* 块中 `-` 和空格开头的行总数应等于 MM；`+` 和空格开头的行总数应等于 mm。

**Patch 程序处理流程**：

1. 读取全部输入，移除 `#` 开头的注释行。
2. 寻找 `@@` 开头的行识别块。
3. 依次检查每个块：
   * 解析 NN, MM, mm。
   * 若不是第一个块，检查 NN 是否不小于前一个块的 NN + MM。
   * 检查块内容行是否合法（以 -, +, 空格开头），且行数符合 MM 和 mm。
4. 若所有块检查通过，开始应用：
   * 对每个块，在原文件中寻找匹配位置。寻找绝对值小于 MM 的整数 $\delta$，使得原文件第 $NN+\delta$ 行开始的 MM 行与块的原文件片段（`-` 和空格行）完全匹配。
   * 若不是第一个块，需满足 $NN+\delta$ 不小于前一个块的匹配位置结束点（即无重叠）。
   * 若存在多个 $\delta$，取 $|\delta|$ 最小的；若仍由多个，取 $\delta$ 最小的。若不存在，补丁损坏。
   * 执行替换：将原文件对应片段替换为块的新文件片段（`+` 和空格行）。
   * **注意**：应用后，该块及后续所有块的 NN 需加上 $\delta$（行号偏移）。

### 输入格式

输入的第一行包含一个正整数 $n$，表示原文件的总行数。
接下来的 $n$ 行文本，表示原文件的内容。
接下来的若干行，表示待应用的补丁。

### 输出格式

输出应用补丁后的文件内容；如果补丁损坏，输出 `Patch is damaged.`。

### 样例

**输入：**

```text
7
bbb
a
1
2
3
4
5
dummy
@@ -1,4 +1,5 @@
-a
+b
 1
+c
 2
 3
@@ -6,2 +6,2 @@
-4
+6
 5
```

**输出：**

```text
bbb
b
1
c
2
3
6
5
```

### 子任务

* 30% 数据：补丁仅包含一个块，且无注释。
* 60% 数据：$n \le 60$，行长 $\le 120$，补丁合法且无偏移（$\delta=0$）。
* 100% 数据：$n \le 2000$，行长 $\le 830$，总长度 $\le 500\text{KiB}$，字符 ASCII 32-126 及换行符，补丁块不超过 25 个。

---

## 题目 4：通讯延迟 (Communication Delay)

**时间限制：** 1.5 秒
**空间限制：** 512 MiB

### 题目描述

给定二维平面上 $n$ 个节点，以及 $m$ 个通讯基站。
第 $i$ 个基站可以覆盖以坐标 $(x_i, y_i)$ 为中心、$2r_i$ 为边长的**正方形区域**，并使正方形区域内（包含边界）所有节点以 $t_i$ 单位时间的延迟进行相互通讯。
求节点 1 到 $n$ 的最短通讯延迟。

### 输入格式

第一行包含空格分隔的两个正整数 $n, m$；
接下来 $n$ 行，每行两个整数 $x_i, y_i$，代表第 $i$ 个节点的坐标；
接下来 $m$ 行，每行四个整数 $x_j, y_j, r_j, t_j$，代表第 $j$ 个通讯基站的坐标，通讯半径与通讯延迟。

### 输出格式

输出一行，即节点 1 到 $n$ 的最短通讯延迟；如果无法通讯，则输出 `Nan`。

### 样例

**输入：**

```text
5 5
0 0
2 4
4 0
5 3
5 5
1 2 2 5
3 5 2 6
2 0 2 1
4 2 2 3
5 4 1 2
```

**输出：**

```text
6
```

### 子任务

* 30% 数据：$n, m \le 100$；
* 额外 30% 数据：每个基站至多覆盖 20 个节点；
* 全部数据：$n, m \le 5000$，$0 \le x_i, y_i, r_i \le 10^9$，$1 \le t_i \le 10^5$。

---

## 题目 5：木板切割 (Board Cutting)

**时间限制：** 1.0 秒
**空间限制：** 512 MiB

### 题目描述

你有一块长度为 $n$ 的木板（编号为 1），被平均分成 $n$ 段（编号 1 到 $n$），第 $i$ 段颜色为 $c_i$。
你要进行 $k$ 次切割操作。第 $i$ 次操作有参数 $x_i, l_i, r_i$：

* 将 $x_i$ 号木板中**段落编号**在 $[l_i, r_i]$ 之间的所有段切割下来，作为第 $i+1$ 号木板。
* 原木板剩余部分重新连接。
* 段落编号固定不变。
* 切下的木板可能为空。

你需要输出每次切割操作切下的木板：

1. 包含多少种不同的颜色？
2. 包含多少个颜色段（极长连续相同颜色段）？

### 输入格式

第一行包含三个正整数 $n, m, k$。
第二行包含 $n$ 个正整数 $c_1, \dots, c_n$，表示颜色。
接下来 $k$ 行，每行三个整数 $x_i, l_i, r_i$，表示切割操作。

### 输出格式

共 $k$ 行，每行两个正整数，分别表示不同颜色数和颜色段数。

### 样例

**输入：**

```text
6 3 5
1 2 2 3 1 2
1 3 4
1 5 5
1 4 5
1 1 6
2 4 4
```

**输出：**

```text
2 2
1 1
0 0
2 2
1 1
```

### 子任务

* 测试点 1-5：$n, m, k \le 2000$。
* 测试点 6-7：$n, m, k \le 10^5$，性质 A（$r_i - l_i \le 1000$）。
* 测试点 8-10：$n, m, k \le 10^5$，性质 B（$c_i = i$）。
* 测试点 11-13：$n, m, k \le 10^5$，性质 C（颜色非递减）。
* 测试点 14-20：$n, m, k \le 10^5$，无特殊限制。
* 全部数据：$1 \le n, m, k \le 10^5$，$1 \le c_i \le m$，$1 \le x_i \le i$。
