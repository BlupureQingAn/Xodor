以下是整理好的第36次CCF计算机软件能力认证（CSP）模拟试题集合。

---

# 第36次CCF计算机软件能力认证

## 题目 1：移动 (Movement)

**时间限制：** 1.0 秒
**空间限制：** 512 MiB

### 题目背景

西西艾弗岛某山脉深处出土了一台远古机器人，具体年代已不可考。初步修缮后，研究人员尝试操控机器人进行些简单的移动。

### 题目描述

整个实验场地被划分为 $n \times n$ 个方格，从 $(1,1)$ 到 $(n,n)$ 进行编号。机器人只能在这些方格间移动，不能走出场地范围。

假设机器人当前位于 $(x,y)$，那么接下来可以向前后左右任意方向移动一格：

* **向前移动 f**：$(x,y) \rightarrow (x,y+1)$
* **向后移动 b**：$(x,y) \rightarrow (x,y-1)$
* **向左移动 l**：$(x,y) \rightarrow (x-1,y)$
* **向右移动 r**：$(x,y) \rightarrow (x+1,y)$

特别地，如果移动的目标位置不在场地范围内，则机器人位置保持不变。这样，使用由 `f`、`b`、`l` 和 `r` 组成的指令序列便可操纵机器人在场地上自由移动。

试处理 $k$ 个查询：每个查询包含一个机器人起始位置 $(x,y)$ （$1 \le x, y \le n$）和一个移动指令序列（由 `f` `b` `l` `r` 四个字母组成的字符串），输出执行完移动指令后的最终位置。

### 输入格式

从标准输入读入数据。
输入的第一行包含空格分隔的两个正整数 $n$ 和 $k$，分别表示场地大小和查询个数。
接下来 $k$ 行：每行包含空格分隔的两个正整数 $x$、$y$ 和一个由 `f` `b` `l` `r` 四个字母组成的字符串，表示一个查询。

### 输出格式

输出到标准输出。
每个查询输出一行：包含空格分隔的两个正整数 $x$ 和 $y$，表示对应查询的最终位置。

### 样例输入

```text
3 2
1 1 ffrrbbll
3 3 frbl
```

### 样例输出

```text
1 1
2 2
```

### 子任务

* 50% 的测试数据满足：指令序列不会试图将机器人移出场地（即无需考虑场地边界）；
* 全部的测试数据满足：$n$、$k$ 和每个指令序列的长度均大于 0 且不超过 100。

---

## 题目 2：梦境巡查 (Dream Inspection)

**时间限制：** 1.0 秒
**空间限制：** 512 MiB

### 题目背景

传说每当月光遍布西西艾弗岛，总有一道身影默默守护着居民们的美梦。

### 题目描述

梦境中的西西艾弗岛由 $n+1$ 个区域组成。梦境巡查员顿顿每天都会从梦之源（0 号区域）出发，顺次巡查 $1, 2, \dots, n$ 号区域，最后从 $n$ 号区域返回梦之源。

在梦境中穿梭需要消耗美梦能量：

1. 从梦之源出发时，顿顿会携带若干初始能量；
2. 从第 $i$ 号区域前往下一区域（$0 \le i \le n$）需要消耗 $a_i$ 单位能量，因此从第 $i$ 号区域出发时，顿顿剩余的美梦能量需要大于或等于 $a_i$ 单位；
3. 顺利到达第 $i$ 号区域（$1 \le i \le n$）后，顿顿可以从当地居民的美梦中汲取 $b_i$ 单位能量作为补给。

假设顿顿初始携带 $w$ 单位美梦能量，那么首先需要保证 $w \ge a_0$，这样顿顿便可消耗 $a_0$ 能量穿梭到 1 号区域、进而获得 $b_1$ 单位能量补给。巡查 1 号区域后，顿顿剩余能量为 $w - a_0 + b_1$，如果该数值大于或等于 $a_1$，顿顿便可继续前往 2 号区域。依此类推，直至最后消耗 $a_n$ 单位能量从 $n$ 号区域返回梦之源，便算是顺利完成整个巡查。

作为一个成熟的梦境巡查员，顿顿已经知晓初始需要携带多少能量可以保证顺利完成巡查。但在一些意外状况下，比如学生们受期末季的困扰而无法安眠，顿顿可能在某些区域无法采集足够的美梦能量。此时，便需要增加初始携带量以备万全。

具体来说，考虑一个简单的情况：在 1 到 $n$ 号区域中，**有且仅有一个区域发生意外**，顿顿无法从该区域获得能量补给。 如果第 $i$ 号区域（$1 \le i \le n$）发生意外（即 $b_i$ 变为 0），则此时为顺利完成巡查，顿顿从梦之源出发所携带的最少初始能量记作 $w(i)$。

试帮助顿顿计算 $w(1), w(2), \dots, w(n)$ 的值。

### 输入格式

从标准输入读入数据。
输入共三行。
第一行包含一个整数 $n$。
第二行包含 $n+1$ 个整数 $a_0, a_1, a_2, \dots, a_n$。
第三行包含 $n$ 个整数 $b_1, b_2, \dots, b_n$。

### 输出格式

输出到标准输出。
输出仅一行，包含空格分隔的 $n$ 个整数 $w(1), w(2), \dots, w(n)$。

### 样例 1

**输入：**

```text
3
5 5 5 5
0 100 0
```

**输出：**

```text
10 20 10
```

### 样例 2

**输入：**

```text
3
9 4 6 2
9 4 6
```

**输出：**

```text
15 10 9
```

### 子任务

* 80% 的测试数据保证 $0 < n \le 1000$；
* 全部测试数据保证 $0 < n \le 10^5$ 且 $0 \le a_i, b_i \le 1000$。

---

## 题目 3：缓存模拟 (Cache Simulation)

**时间限制：** 1.0 秒
**空间限制：** 512 MiB

### 题目背景

西西艾弗岛半导体制造厂近期正在研发一种新型的处理器产品。该处理器的缓存，计划采用组相连的方式。我们需要对缓存的工作过程进行模拟。

### 题目描述

处理器的缓存包含若干缓存行。以缓存行的大小为单位，将全部内存空间划分为若干块（编号从 0 开始）。

**$n$-路组相联**结构定义如下：

* 每 $n$ 个缓存行划分为一组。共有 $N$ 个组（编号 0 到 $N-1$）。
* 编号为 $k$ 的内存块仅可以被存储在编号为 $(k \div n) \pmod N$ 的组中。其中 $\div$ 表示忽略余数的整除。

**读写过程**：
给定要读取或写入的内存块编号，确定其所属的组编号。

1. **命中**：该组某个缓存行已存储该内存块数据。
   * 直接使用或修改。
2. **未命中**：该组所有缓存行均未存储该数据。
   * **载入**：从内存读取数据存入该组一个缓存行。
   * 若有空闲缓存行，存入其中。
   * 若无空闲，需**替换**。

**替换策略 (LRU)**：

* 该组缓存行按使用时间排序。
* 每次读/写一个缓存行，将其移到队列最前端。
* 替换时，选择队列最后一个缓存行。
* **写回**：若被替换的缓存行曾被修改（写操作），需先将数据写入内存，再载入新数据。

题目将给出处理器运行时对内存的读写指令（初始缓存为空），你需要输出实际对内存的读写操作序列。

### 输入格式

从标准输入读入数据。
第一行包含三个整数 $n, N, q$，分别表示组相联路数、组数、指令数量。
接下来 $q$ 行，每行包含两个整数 $o$ 和 $a$。$o=0$ 表示读，$o=1$ 表示写；$a$ 为内存块编号。

### 输出格式

输出到标准输出。
输出若干行，每行包含两个整数 $o'$ 和 $a'$，表示实际对内存的读写操作（$o'=0$ 读，$o'=1$ 写，$a'$ 为块编号）。

### 样例输入

```text
4 8 8
0 0
0 1
1 2
0 1
1 0
0 32
1 33
0 34
```

### 样例输出

```text
0 0
0 1
0 2
0 32
1 2
0 33
0 34
```

### 子任务

* 20% 数据：$n=1, N=1$；
* 40% 数据：$n=1$；
* 20% 数据：$N=1, q \le n$；
* 100% 数据：$1 \le n, N, n \times N \le 65536$，且 $n, N$ 为 2 的幂次；$1 \le q \le 10^5$，$0 \le a < 2^{30}$。

---

## 题目 4：跳房子 (Hopscotch)

**时间限制：** 0.5 秒
**空间限制：** 512 MiB

### 题目描述

在地面上有一字排开的 $n$ 个格子，第 $i$ 个格子上写着的数字是 $a_i$。满足 $a_i < i$ 且 $a_n = 0$。

**规则**：

1. 一开始站在第 1 个格子上。
2. 在第 $i$ 个格子上最多能往前跳 $k_i$ 格，且不能超过第 $n$ 个格子。
3. 即可以跳到第 $i+1$ 到第 $\min(n, i+k_i)$ 之间的任意格子。
4. 跳跃后落到第 $j$ 个格子时，**必须**后退 $a_j$ 格，最终停在第 $j - a_j$ 个格子。
5. 下一次跳跃从停留的格子开始。

求最少跳跃多少次才能到达第 $n$ 个格子。如果不可以到达输出 -1。

### 输入格式

第一行一个正整数 $n$。
第二行 $n$ 个非负整数 $a_1, \dots, a_n$。
第三行 $n$ 个非负整数 $k_1, \dots, k_n$。

### 输出格式

输出一行一个整数表示最少跳跃次数，或 -1。

### 样例 1

**输入：**

```text
10
0 1 1 1 1 3 1 0 3 0
2 4 5 4 1 4 1 3 5 3
```

**输出：**

```text
4
```

### 样例 2

**输入：**

```text
5
0 1 2 3 0
3 4 4 10 15
```

**输出：**

```text
-1
```

### 子任务

* 30% 分数：$n \le 1000$；
* 30% 分数：对于任意 $i < j$，都有 $k_i \le k_j$；
* 40% 分数：无特殊限制。
* 全部数据：$1 \le n \le 10^5$，$0 \le a_i < i$，$1 \le k_i \le 10^9$。

---

## 题目 5：梦魔 (Nightmare)

**时间限制：** 3.0 秒
**空间限制：** 512 MiB

### 题目描述

有 $n$ 只梦魔站成一列，第 $i$ 只梦魔有防御力 $a_i$。击杀第 $i$ 只梦魔后，小 C 的攻击力上升 $b_i$。

**游戏规则**：

1. 小 C 被传送到两只相邻梦魔之间（位置 $i$ 表示在第 $i$ 和 $i+1$ 只梦魔之间）。
2. 小 C 可以攻击左边或右边离自己最近的梦魔，前提是当前攻击力 **不严格小于** 该梦魔的防御力。
3. 击杀后梦魔移除，相邻的梦魔补位。
4. 目标是击杀所有梦魔。

**问题**：
对于每个可能的降落位置 $i$ ($1 \le i \le n-1$)，求能击杀所有梦魔的**最小初始攻击力** $p_i$。

题目包含 $q$ 次变动。每次变动会修改若干只梦魔的 $a_i$ 和 $b_i$（每次变动都是基于初始局面，相互独立）。你需要对每次变动输出 $p_1 \oplus p_2 \oplus \dots \oplus p_{n-1}$ 的值（$\oplus$ 为按位异或）。

### 输入格式

第一行一个正整数 $n$。
第二行 $n$ 个正整数 $a_1, \dots, a_n$。
第三行 $n$ 个正整数 $b_1, \dots, b_n$。
第四行一个正整数 $q$。
接下来依次描述 $q$ 次变动。每次变动第一行为整数 $k$，表示修改个数；接下来 $k$ 行每行三个整数 $i, a'_i, b'_i$。

### 输出格式

对每次变动输出一行一个整数，表示 $\bigoplus_{i=1}^{n-1} p_i$ 的值。

### 样例输入

```text
6
4 9 3 1 7 7
4 2 1 3 1 4
2
2
3 8 1
5 4 3
0
```

### 样例输出

```text
9
1
```

### 子任务

* 30% 分数：$n \le 1000$；
* 40% 分数：$n \le 10^5, q \le 5$；
* 10% 分数：$1 \le a_i, a'_i \le n$；
* 20% 分数：无特殊限制。
* 全部数据：$1 \le n \le 2 \times 10^6$，$0 \le q \le 20$，$1 \le a, b \le 10^9$。每次变动的 $k$ 之和不超过 $5 \times 10^5$。
